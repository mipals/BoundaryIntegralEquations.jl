<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Background Theory · BoundaryIntegralEquations.jl</title><script data-outdated-warner src="../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.045/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.13.24/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../assets/documenter.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit"><a href="../">BoundaryIntegralEquations.jl</a></span></div><form class="docs-search" action="../search/"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li><a class="tocitem" href="../">Home</a></li><li class="is-active"><a class="tocitem" href>Background Theory</a><ul class="internal"><li><a class="tocitem" href="#Getting-the-computer-to-understand-functions"><span>Getting the computer to understand functions</span></a></li><li><a class="tocitem" href="#Elements"><span>Elements</span></a></li><li><a class="tocitem" href="#Quadrature"><span>Quadrature</span></a></li><li><a class="tocitem" href="#The-Boundary-Element-Method"><span>The Boundary Element Method</span></a></li><li><a class="tocitem" href="#The-Fast-Multipole-Method-and-BEM"><span>The Fast Multipole Method and BEM</span></a></li><li><a class="tocitem" href="#H-Matrices"><span>H-Matrices</span></a></li></ul></li><li><span class="tocitem">2D</span><ul><li><a class="tocitem" href="../2d_kernels/">Kernels</a></li><li><a class="tocitem" href="../2d_elements/">Element Types</a></li><li><a class="tocitem" href="../2d_meshes/">Meshes</a></li></ul></li><li><span class="tocitem">3D</span><ul><li><a class="tocitem" href="../3d_kernels/">Kernels</a></li><li><a class="tocitem" href="../3d_elements/">Element Types</a></li><li><a class="tocitem" href="../3d_meshes/">Meshes</a></li><li><a class="tocitem" href="../3d_fast_operators/">Fast Operators</a></li><li><a class="tocitem" href="../3d_losses/">Viscous and Thermal Losses</a></li><li><a class="tocitem" href="../3d_rosebem/">ROSEBEM</a></li><li><a class="tocitem" href="../3d_experimental/">Experimental Features</a></li><li><a class="tocitem" href="../3d_analytical/">Analytical Expressions</a></li></ul></li><li><span class="tocitem">Examples</span><ul><li><a class="tocitem" href="../examples/2d_element_usage/">Curve Functions (2D)</a></li><li><a class="tocitem" href="../examples/2d_infinite_cylinder/">Scattering of infinite cylinder (2D)</a></li><li><a class="tocitem" href="../examples/3d_element_usage/">Surface Functions (3D)</a></li><li><a class="tocitem" href="../examples/3d_rigid_sphere/">Rigid sphere scattering (3D - Exterior)</a></li><li><a class="tocitem" href="../examples/3d_oscilating_sphere/">Oscilating sphere (3D - Interior)</a></li><li><a class="tocitem" href="../examples/3d_pulsating_sphere/">Pulsating sphere (3D - Interior)</a></li><li><a class="tocitem" href="../examples/3d_cube_wave/">Cube with vibrating sides (3D - Interior)</a></li><li><a class="tocitem" href="../examples/3d_cube_wave_anechoic/">Cube with anechoic condition (3D - Interior)</a></li><li><a class="tocitem" href="../examples/3d_lossy_sphere/">Lossy sphere (3D - Exterior)</a></li><li><a class="tocitem" href="../examples/3d_rosebem/">ROSEBEM: Rigid sphere scattering</a></li></ul></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href>Background Theory</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Background Theory</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/mipals/BoundaryIntegralEquations.jl/blob/main/docs/src/background_theory.md" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="Theoretical-Background"><a class="docs-heading-anchor" href="#Theoretical-Background">Theoretical Background</a><a id="Theoretical-Background-1"></a><a class="docs-heading-anchor-permalink" href="#Theoretical-Background" title="Permalink"></a></h1><p>This page includes the theoretical foundations of <code>BoundaryIntegralEquations.jl</code>.</p><h2 id="Getting-the-computer-to-understand-functions"><a class="docs-heading-anchor" href="#Getting-the-computer-to-understand-functions">Getting the computer to understand functions</a><a id="Getting-the-computer-to-understand-functions-1"></a><a class="docs-heading-anchor-permalink" href="#Getting-the-computer-to-understand-functions" title="Permalink"></a></h2><p>In the most basic terms computers are only capable of understanding numbers, meaning that they are inherently unable to solve equations where the unknowns are functions. This is a problem when trying to solve BIEs. To resolve this issue the functions are instead approximated using parametrizations for which the coefficients (numbers) are unknown. Intuitively these numbers are exactly what the computer is then tasked to find. For element methods this parametrization is chosen to be the simplest possible: A linear combination of functions</p><p class="math-container">\[p(\mathbf{x}) \approx \mathbf{T}(\mathbf{x})\mathbf{p} 
    = 
    \begin{bmatrix} T_1(\mathbf{x}) &amp;  T_2(\mathbf{x}) &amp;  \dots  &amp;  T_n(\mathbf{x}) \end{bmatrix}
    \begin{bmatrix} p_1             \\ p_2             \\ \vdots \\ p_n             \end{bmatrix}. \]</p><p>Note that linearity is with respect to the unknown parameters <span>$\mathbf{p}$</span>, but not necessarily in the known basis functions <span>$\mathbf{T}(\mathbf{x})$</span>. A useful, but not necessary, property is called the Cardinal property stating that </p><p class="math-container">\[T_i(\mathbf{x}_j) = \delta_{ij} = 
    \begin{cases}
        1, \quad i = j\\
        0, \quad i \neq j    
    \end{cases}.\]</p><p>The usefulness is due the property making the <span>$j$</span>th value of <span>$\mathbf{p}$</span> interpretable as the value of the function at point <span>$\mathbf{x}_j$</span> as</p><p class="math-container">\[\mathbf{T}(\mathbf{x}_j)\mathbf{p} = p_j.\]</p><p>One might ask: <em>How does the above relate to The Boundary Element Method?</em> The answer is that the functions <span>$\mathbf{T}_i$</span> are chosen to be simpler functions with support equal to only a few subdomains of the original domain. These subdomains are commonly referred to as elements. </p><h2 id="Elements"><a class="docs-heading-anchor" href="#Elements">Elements</a><a id="Elements-1"></a><a class="docs-heading-anchor-permalink" href="#Elements" title="Permalink"></a></h2><p>A key insight is that the element serves two purposes: It represents a subdomain of the original domain (also referred to as the geometry) while also describing parts of the unknown function of interest. In the case of surface elements, which are the ones used for BEMs, the parametrization of an element (denoted by <span>$e$</span> in the following) is done as</p><p class="math-container">\[    \mathbf{x}^e(\mathbf{u}) = \mathbf{X}^e\mathbf{N}(\mathbf{u}) \in \Gamma^e, \quad \forall \mathbf{u} \in \mathcal{L},\]</p><p>where <span>$\mathbf{X}^e$</span> is a matrix with columns equal to the interpolation nodes of the geometry, <span>$\mathbf{N}(\mathbf{u})$</span> are the shape functions, <span>$\Gamma^e$</span> is the element in global coordinates and <span>$\mathcal{L}$</span> are the local coordinates. In 3D a triangular element can look as</p><p><img src="../figures/sfd.png" alt="Elements"/></p><p>The element description of the geometry allows for the function approximation of <span>$p$</span> to be done easily as</p><p class="math-container">\[    p(\mathbf{x}^e(\mathbf{u})) = \mathbf{T}(\mathbf{x}^e(\mathbf{u}))\mathbf{p} = \underbrace{\mathbf{T}(\mathbf{x}(\mathbf{u}))(\mathbf{L}^e)^\top}_{\mathbf{T}^e(\mathbf{u})}\underbrace{\mathbf{L}^e\mathbf{p}}_{\mathbf{p}^e} = \mathbf{T}^e(u)\mathbf{p}^e, \quad \mathbf{u} \in \mathcal{L}\]</p><p>where <span>$\mathbf{L}^e$</span> is a permutation-like matrix that extracts the relevant values of <span>$\mathbf{p}$</span> and orders them such that they correspond to the local basis functions of <span>$\mathbf{T}^e(\mathbf{u})$</span>. The local basis functions are usually chosen as (Lagrange) polynomials of degree <span>$d$</span>, but other basis functions such as e.g. Legendre polynomials and splines have also been applied with success. </p><div class="admonition is-info"><header class="admonition-header">Example: Element Localization Matrix</header><div class="admonition-body"><p>For a linear element <span>$e$</span> all three corners corresponds to a value of the global vector <span>$\mathbf{p}$</span>. For e.g. an element could have local corner values given by <span>$\mathbf{p}^e = \begin{bmatrix}p_1 &amp; p_4 &amp; p_3 \end{bmatrix}^\top$</span>. This element would have <span>$\mathbf{L}^e$</span> given as</p><p class="math-container">\[    \mathbf{L}^e = 
    \begin{bmatrix}
    1 &amp; 0 &amp; 0 &amp; 0 &amp; ... &amp; 0\\
    0 &amp; 0 &amp; 0 &amp; 1 &amp; ... &amp; 0\\
    0 &amp; 0 &amp; 1 &amp; 0 &amp; ... &amp; 0
    \end{bmatrix}.\]</p><p>Note that <span>$\mathbf{L}^e$</span> is only an artifact of the mathematical description. Any reasonable implementation should utilize indexing instead of multiplication with <span>$\mathbf{L}^e$</span>.</p></div></div><h2 id="Quadrature"><a class="docs-heading-anchor" href="#Quadrature">Quadrature</a><a id="Quadrature-1"></a><a class="docs-heading-anchor-permalink" href="#Quadrature" title="Permalink"></a></h2><p>The underlying mathematics of the BEM is that of surface integrals. In most cases it is not possible to compute these analytically. Instead, a quadrature scheme is used to approximate the integrals. To do so the element in global coordinates is transformed into local coordinates using the Jacobian function describing the local deformation from the transformation. For 2D and 3D this deformation looks as follows</p><p class="math-container">\[\begin{alignat*}{3}
    \text{2D:} &amp; \quad \text{jacobian}(u)   &amp;&amp;= \left\|\mathbf{X}^e \frac{\mathrm{d}\mathbf{N}(u)}{\mathrm{d}u}\right\|_2 \quad &amp;&amp; \text{(length deformation)}\\
    \text{3D:} &amp; \quad \text{jacobian}(u,v) &amp;&amp;= \left\|\left(\mathbf{X}^e \frac{\mathrm{d}\mathbf{N}(u,v)}{\mathrm{d}u}\right) \times \left(\mathbf{X}^e \frac{\mathrm{d}\mathbf{N}(u,v)}{\mathrm{d}v}\right) \right\|_2 \quad &amp;&amp; \text{(area deformation)}
\end{alignat*}\]</p><p>Applying this the surface integral can be transformed into local coordinates and computed using a suitable quadrature scheme as</p><p class="math-container">\[    \int_{\Gamma^e} f(\mathbf{x})\ \mathrm{d}S_\mathbf{x} = \int_\mathcal{L} \text{jacobian}(\mathbf{u})f(\mathbf{u})\ \mathrm{d}\mathbf{u} \approx \sum_{i=1}^{Q} \text{jacobian}(\mathbf{u}_i)w_if(\mathbf{u}_i),\]</p><p>where <span>$\mathbf{u}_i$</span> is the quadrature point with corresponding weights <span>$w_i$</span>.</p><h2 id="The-Boundary-Element-Method"><a class="docs-heading-anchor" href="#The-Boundary-Element-Method">The Boundary Element Method</a><a id="The-Boundary-Element-Method-1"></a><a class="docs-heading-anchor-permalink" href="#The-Boundary-Element-Method" title="Permalink"></a></h2><p>In simple terms the Boundary Element Method (BEM) is a method for solving Boundary Integral Equations through a discretization of both the unknown function and domain. In this package the main focus is solving BIEs through the so-called collocation approach. This approach is a particular case of the Galerkin approach where the test function is equal to the sum of Dirac-delta functions</p><p class="math-container">\[\phi(\mathbf{x}) =  \mathbf{a}^\top
                    \begin{bmatrix}
                        \delta\left(\mathbf{x} - \mathbf{t}_1\right)\\ 
                        \delta\left(\mathbf{x} - \mathbf{t}_2\right)\\ 
                        \vdots\\
                        \delta\left(\mathbf{x} - \mathbf{t}_n\right)\\ 
                    \end{bmatrix},\]</p><p>where <span>$\mathbf{a} \in \mathbb{C}^n$</span> is a vector of arbitrary constants and <span>$\mathbf{t}_i \in \mathbb{R}^3$</span> are the nodal mesh positions (target points). </p><p class="math-container">\[\mathbf{a}^\top
\begin{bmatrix}
    c(\mathbf{t}_1)p(\mathbf{t}_1)\\ 
    c(\mathbf{t}_2)p(\mathbf{t}_2)\\ 
    \vdots \\ 
    c(\mathbf{t}_n)p(\mathbf{t}_n)
\end{bmatrix} 
+ 
\mathbf{a}^\top
\begin{bmatrix}
    \int_\Gamma\frac{\partial G(\mathbf{t}_1, \mathbf{y})}{\partial\mathbf{n}(\mathbf{y})}p(\mathbf{y})\ \mathrm{d}S_\mathbf{y}\\
    \int_\Gamma\frac{\partial G(\mathbf{t}_2, \mathbf{y})}{\partial\mathbf{n}(\mathbf{y})}p(\mathbf{y})\ \mathrm{d}S_\mathbf{y}\\
    \vdots \\
    \int_\Gamma\frac{\partial G(\mathbf{t}_n, \mathbf{y})}{\partial\mathbf{n}(\mathbf{y})}p(\mathbf{y})\ \mathrm{d}S_\mathbf{y}
\end{bmatrix}
=
\mathbf{a}^\top
\begin{bmatrix}
    sk\int_\Gamma G(\mathbf{t}_1, \mathbf{y})v_f(\mathbf{y})\ \mathrm{d}S_\mathbf{y}\\
    sk\int_\Gamma G(\mathbf{t}_2, \mathbf{y})v_f(\mathbf{y})\ \mathrm{d}S_\mathbf{y}\\
    \vdots \\
    sk\int_\Gamma G(\mathbf{t}_n, \mathbf{y})v_f(\mathbf{y})\ \mathrm{d}S_\mathbf{y}
\end{bmatrix}.\]</p><p>In its current form the solution to the above equation is a <em>function</em> which a computer can not be tasked to find. Instead, the problem is made computationally tractable by parametrizing the functions <span>$p$</span> and <span>$v_s$</span> as shown previously. As such the above reduces to</p><p class="math-container">\[\mathbf{a}^\top
\begin{bmatrix}
    c(\mathbf{t}_1)\mathbf{T}(\mathbf{t}_1)\mathbf{p}\\ 
    c(\mathbf{t}_2)\mathbf{T}(\mathbf{t}_2)\mathbf{p}\\ 
    \vdots \\ 
    c(\mathbf{t}_n)\mathbf{T}(\mathbf{t}_n)\mathbf{p}
\end{bmatrix}
+ 
\mathbf{a}^\top
\begin{bmatrix}
    \int_\Gamma\frac{\partial G(\mathbf{t}_1, \mathbf{y})}{\partial\mathbf{n}(\mathbf{y})}\mathbf{T}(\mathbf{y})\mathbf{p}\ \mathrm{d}S_\mathbf{y}\\
    \int_\Gamma\frac{\partial G(\mathbf{t}_2, \mathbf{y})}{\partial\mathbf{n}(\mathbf{y})}\mathbf{T}(\mathbf{y})\mathbf{p}\ \mathrm{d}S_\mathbf{y}\\
    \vdots \\
    \int_\Gamma\frac{\partial G(\mathbf{t}_n, \mathbf{y})}{\partial\mathbf{n}(\mathbf{y})}\mathbf{T}(\mathbf{y})\mathbf{p}\ \mathrm{d}S_\mathbf{y}
\end{bmatrix}
\approx
\mathbf{a}^\top
\begin{bmatrix}
    sk\int_\Gamma G(\mathbf{t}_1, \mathbf{y})\mathbf{T}(\mathbf{y})\mathbf{v}_f\ \mathrm{d}S_\mathbf{y}\\
    sk\int_\Gamma G(\mathbf{t}_2, \mathbf{y})\mathbf{T}(\mathbf{y})\mathbf{v}_f\ \mathrm{d}S_\mathbf{y}\\
    \vdots \\
    sk\int_\Gamma G(\mathbf{t}_n, \mathbf{y})\mathbf{T}(\mathbf{y})\mathbf{v}_f\ \mathrm{d}S_\mathbf{y}
\end{bmatrix}.\]</p><p>By the cardinal property of the basis functions it follows that</p><p class="math-container">\[\mathbf{a}^\top
\left(
\text{diag}\left(\begin{bmatrix}
    c(\mathbf{t}_1)\\ 
    c(\mathbf{t}_2)\\ 
    \vdots \\ 
    c(\mathbf{t}_n)
\end{bmatrix}\right)
+ 
\begin{bmatrix}
    \int_\Gamma\frac{\partial G(\mathbf{t}_1, \mathbf{y})}{\partial\mathbf{n}(\mathbf{y})}\mathbf{T}(\mathbf{y})\ \mathrm{d}S_\mathbf{y}\\
    \int_\Gamma\frac{\partial G(\mathbf{t}_2, \mathbf{y})}{\partial\mathbf{n}(\mathbf{y})}\mathbf{T}(\mathbf{y})\ \mathrm{d}S_\mathbf{y}\\
    \vdots \\
    \int_\Gamma\frac{\partial G(\mathbf{t}_n, \mathbf{y})}{\partial\mathbf{n}(\mathbf{y})}\mathbf{T}(\mathbf{y})\ \mathrm{d}S_\mathbf{y}
\end{bmatrix}\right)\mathbf{p}
\approx
\mathbf{a}^\top
\begin{bmatrix}
    sk\int_\Gamma G(\mathbf{t}_1, \mathbf{y})\mathbf{T}(\mathbf{y})\ \mathrm{d}S_\mathbf{y}\\
    sk\int_\Gamma G(\mathbf{t}_2, \mathbf{y})\mathbf{T}(\mathbf{y})\ \mathrm{d}S_\mathbf{y}\\
    \vdots \\
    sk\int_\Gamma G(\mathbf{t}_n, \mathbf{y})\mathbf{T}(\mathbf{y})\ \mathrm{d}S_\mathbf{y}
\end{bmatrix}\mathbf{v}_f.\]</p><p>Since the above has to hold for all <span>$\mathbf{a} \in \mathbb{C}^n$</span> it follows that</p><p class="math-container">\[\left(\text{diag}\left(\begin{bmatrix}
    c(\mathbf{t}_1)\\ 
    c(\mathbf{t}_2)\\ 
    \vdots \\ 
    c(\mathbf{t}_n)
\end{bmatrix}\right)
+ 
\mathbf{F}\right)\mathbf{p}
=
sk\mathbf{G}\mathbf{v}_s.\]</p><p>For simplification purposes the above is sometimes written as</p><p class="math-container">\[\mathbf{H}\mathbf{p} = \mathbf{G}\partial_\mathbf{n}\mathbf{p} .\]</p><p>We now briefly explain how to compute the <span>$j$</span>th row of <span>$\mathbf{H}$</span>. To do so element description of the unknown function used differently as <span>$\mathbf{p}^e$</span> is not part of the equation. Instead, we use the split as follows </p><p class="math-container">\[\begin{aligned}
\int_\Gamma\frac{\partial G(\mathbf{t}_j, \mathbf{y})}{\partial\mathbf{n}(\mathbf{y})}\mathbf{T}(\mathbf{y})\mathbf{p}\ \mathrm{d}S_\mathbf{y} 
&amp;\approx \sum_{e=1}^{N}\left(\int_{\Gamma^e}\frac{\partial G(\mathbf{t}_j, \mathbf{y})}{\partial\mathbf{n}(\mathbf{y})}\mathbf{T}(\mathbf{y})(\mathbf{L}^e)^\top\mathbf{L}^e\ \mathrm{d}S_\mathbf{y}\right) \mathbf{p}\\
&amp;\approx \left(\underbrace{\sum_{e=1}^{N}\left(\sum_{i=1}^{Q(\mathbf{z}_j,e)}\frac{\partial G(\mathbf{t}_j, \mathbf{y}^e(\mathbf{u}_i))}{\partial\mathbf{n}(\mathbf{y}^e(\mathbf{u}_i))}\text{jacobian}(\mathbf{u}_i)w_i\mathbf{T}^e(\mathbf{u}_i)\right)\mathbf{L}^e}_{j\text{th row of }\mathbf{H}}\right)\mathbf{p},
\end{aligned}\]</p><p>where the number of quadrature points, <span>$Q(\mathbf{z}_1,e)$</span>, is depended on element location with respect to the collocation point <span>$\mathbf{t}_1$</span>. Note that approximation in the first line of the above is due to approximation of the geometry using elements while the second approximation is due to the integration error. A similar approach can be applied for the rows of <span>$\mathbf{H}$</span>.</p><p>A downside of the BEM is that the resulting matrices <span>$\mathbf{H}, \mathbf{G} \in \mathbb{C}^{n\times n}$</span> are dense, meaning that storing the two matrices scales as <span>$\mathcal{O}(n^2)$</span> rendering the direct application of the method unusable large <span>$n$</span>.</p><h2 id="The-Fast-Multipole-Method-and-BEM"><a class="docs-heading-anchor" href="#The-Fast-Multipole-Method-and-BEM">The Fast Multipole Method and BEM</a><a id="The-Fast-Multipole-Method-and-BEM-1"></a><a class="docs-heading-anchor-permalink" href="#The-Fast-Multipole-Method-and-BEM" title="Permalink"></a></h2><p>The Fast Multipole Method (FMM) can be used to accelerate the multiplication with the BEM matrices <span>$\mathbf{H}$</span> and <span>$\mathbf{G}$</span>. Throughout the years many good resources that explain the intricacies of the FMM have been written. As such the details will here be left out. Instead, the focus will be on how to apply a 3rd-party FMM into an existing BEM framework. As an example the focus will be on the <em>Flatiron Institute Fast Multipole Libraries</em>, as this is the library currently interfaced in <code>BoundaryIntegralEquations.jl</code>. This library can be used to accelerate sums of the following form from <span>$O(M)$</span> to <span>$O(\text{log}(M))$</span></p><p class="math-container">\[    \begin{aligned}
    u(\mathbf{x}) 
    &amp;= \sum_{j=1}^M\left[4\pi c_jG(\mathbf{x}, \mathbf{y}_j) - 4\pi v_j\mathbf{n}(\mathbf{y}_j)\cdot\nabla G(\mathbf{x},\mathbf{y}_j)\right],
    \end{aligned}\]</p><p>where the <span>$j$</span>th term is excluded from the sum if <span>$\mathbf{x} = \mathbf{y}_j$</span>. The question is now: <em>How can this be used to speed up multiplication with the BEM matrices?</em></p><p>To see how we start by simplifying things by assuming that each element requires the same amount of quadrature points (this will cause numerical issues that are then fixed by a nearfield correction step), <span>$Q$</span>, and that we want to multiply with a known vector <span>$\mathbf{z}$</span>. Then for a row of <span>$\mathbf{G}$</span> we have that</p><p class="math-container">\[\begin{aligned}
    \left(\underbrace{\int_\Gamma G(\mathbf{t}_k,\mathbf{y})\mathbf{T}(\mathbf{y})\ \mathrm{d}S_\mathbf{y}}_{k\text{th row of } \mathbf{G}}\right)\mathbf{z}
    &amp;\approx
    \left(\sum_{e=1}^{N}\left(\sum_{i=1}^{Q}G(\mathbf{t}_k, \mathbf{y}^e(\mathbf{u}_i))\text{jacobian}(\mathbf{u}_i)w_i\mathbf{T}^e(\mathbf{u}_i)\right)\mathbf{L}^e\right)\mathbf{z}\\
    &amp;= \left(\sum_{j=1}^{NQ}G(\mathbf{x}, \mathbf{y}_j)\underbrace{\text{jacobian}(\mathbf{u}_j)w_j\mathbf{T}^{e(j)}(\mathbf{u}_j)\mathbf{L}^{e(j)}}_{j\text{th row of } \mathbf{C}}\right)\mathbf{z}\\
    &amp;= 
    \begin{bmatrix}
        G(\mathbf{t}_k, \mathbf{y}_1) &amp; G(\mathbf{t}_k, \mathbf{y}_2,) &amp; \dots &amp; G(\mathbf{t}_k, \mathbf{y}_{NQ})
    \end{bmatrix}
    \mathbf{C}\mathbf{z}
\end{aligned}\]</p><p>where the subscript <span>$j$</span> refers to an ordering of the collection of Gaussian points from all elements and <span>$e(j)$</span> is a function that returns the element number that Gaussian point <span>$j$</span> is located on. Furthermore, the matrix <span>$\mathbf{C}$</span> can be thought of as a transformation from <span>$\mathbf{z}$</span> into the coefficients <span>$4\pi c_j$</span>. A similar approach can be applied to <span>$\mathbf{H}$</span></p><p class="math-container">\[\begin{aligned}
    \left(\underbrace{\int_\Gamma\frac{\partial G(\mathbf{t}_k, \mathbf{y})}{\partial\mathbf{n}(\mathbf{y})}\mathbf{T}(\mathbf{y})\ \mathrm{d}S_\mathbf{y}}_{k\text{th row of } \mathbf{H}}\right)\mathbf{y}
    &amp;\approx 
    \left(\sum_{e=1}^{N}\left(\sum_{i=1}^{Q}\frac{\partial G(\mathbf{t}_k, \mathbf{y}^e(\mathbf{u}_i))}{\partial\mathbf{n}(\mathbf{y})}\text{jacobian}(\mathbf{u}_i)w_i\mathbf{T}^e(\mathbf{u}_i)\right)\mathbf{L}^e\right)\mathbf{z}\\
    &amp;= \left(\sum_{j=1}^{NQ}\nabla G(\mathbf{t}_k, \mathbf{y}_j)\cdot \mathbf{n}(\mathbf{y}_j)\underbrace{\text{jacobian}(\mathbf{u}_j)w_j\mathbf{T}^{e(j)}(\mathbf{u}_j)\mathbf{L}^{e(j)}}_{j\text{th row of }\mathbf{C}}\right)\mathbf{z}\\
    &amp;= 
    \begin{bmatrix}
        \nabla G(\mathbf{t}_k, \mathbf{y}_1)\cdot \mathbf{n}(\mathbf{y}_1) &amp;
        \dots &amp;
        \nabla G(\mathbf{t}_k, \mathbf{y}_{NQ})\cdot \mathbf{n}(\mathbf{y}_{NQ})
    \end{bmatrix}
    \mathbf{C}\mathbf{z},
\end{aligned}\]</p><p>where <span>$\mathbf{C}$</span> is a matrix that transforms <span>$\mathbf{z}$</span> into the coefficients <span>$4\pi v_j$</span>. The two equations highlights how the FMM can be applied for problems where the number of Gaussian points on each element is equal. However, in practical cases this approach will be victim to numerical instabilities due to numerical errors stemming from the integration of elements close to the collocation point. To resolve this issue the BEM matrices is split into parts</p><p class="math-container">\[        \mathbf{A} = \mathbf{B}\mathbf{C} + \mathbf{S}, \quad \mathbf{G} \in\mathbb{C}^{n\times NQ},\ \mathbf{S}\in\mathbb{C}^{n\times n},\ \mathbf{C}\in\mathbb{R}^{NQ\times n}.\]</p><p>Here <span>$\mathbf{B}$</span> is the part approximated by the FMM (using <span>$Q$</span> Gaussian points on each element), <span>$\mathbf{C}$</span> is the coefficient mapping, and <span>$\mathbf{S}$</span> the nearfield correction. In short the nearfield correction subtract the wrong integration done by using only <span>$Q$</span> Gaussian points and adds on the correct integration instead. It is important to note that <span>$\mathbf{S}$</span> and <span>$\mathbf{C}$</span> are both highly sparse matrices, meaning that both assembly and multiplication with these scale <span>$\mathcal{O}(n\tau)$</span> where <span>$\tau \ll n$</span>. This means that using an approximate scheme for <span>$\mathbf{B}$</span> with a multiplication that scales linear in time and memory result in a representation of <span>$\mathbf{A}$</span> that scales similarly.</p><p><img src="../figures/nearfield_correction.png" alt="Nearfield Correction"/></p><h2 id="H-Matrices"><a class="docs-heading-anchor" href="#H-Matrices">H-Matrices</a><a id="H-Matrices-1"></a><a class="docs-heading-anchor-permalink" href="#H-Matrices" title="Permalink"></a></h2><p>The <span>$\mathcal{H}$</span>-matrix approach differs from the FMM by the fact that it does not accelerate the sums directly. Instead, it approximates parts of the matrix that corresponds to performing the integration for all the <span>$n$</span> collocation points at the same time. In particular, it approximates the <span>$\mathbf{B}$</span> part of the BE matrix split as</p><p class="math-container">\[\mathbf{B} = 
    \begin{bmatrix}
        G(\mathbf{x}_1,\mathbf{y}_1)  &amp; G(\mathbf{x}_1,\mathbf{y}_2) &amp; \dots    &amp; G(\mathbf{x}_1,\mathbf{y}_{NQ}) \\
        G(\mathbf{x}_2,\mathbf{y}_1)  &amp; G(\mathbf{x}_2,\mathbf{y}_2) &amp; \dots    &amp; G(\mathbf{x}_2,\mathbf{y}_{NQ}) \\
        \vdots          &amp; \vdots         &amp; \ddots   &amp; \vdots            \\
        G(\mathbf{x}_n,\mathbf{y}_1)  &amp; G(\mathbf{x}_n,\mathbf{y}_2) &amp; \dots    &amp; G(\mathbf{x}_n,\mathbf{y}_{NQ})
    \end{bmatrix},\]</p><p>for the <span>$\mathbf{G}$</span>-matrix and as</p><p class="math-container">\[ \mathbf{B} = 
    \begin{bmatrix}
        \mathbf{n}(\mathbf{y}_1)^\top G(\mathbf{x}_1,\mathbf{y}_1)  &amp; \mathbf{n}(\mathbf{y}_2)^\top G(\mathbf{x}_1,\mathbf{y}_2) &amp; \dots    &amp; \mathbf{n}(\mathbf{y}_{NQ})^\top G(\mathbf{x}_1,\mathbf{y}_{NQ})\\
        \mathbf{n}(\mathbf{y}_1)^\top G(\mathbf{x}_2,\mathbf{y}_1)  &amp; \mathbf{n}(\mathbf{y}_2)^\top G(\mathbf{x}_2,\mathbf{y}_2) &amp; \dots    &amp; \mathbf{n}(\mathbf{y}_{NQ})^\top G(\mathbf{x}_2,\mathbf{y}_{NQ})\\
        \vdots                          &amp; \vdots                         &amp; \ddots   &amp; \vdots \\
        \mathbf{n}(\mathbf{y}_1)^\top G(\mathbf{x}_n,\mathbf{y}_1)  &amp; \mathbf{n}(\mathbf{y}_2)^\top G(\mathbf{x}_n,\mathbf{y}_2) &amp; \dots    &amp; \mathbf{n}(\mathbf{y}_{NQ})^\top G(\mathbf{x}_n,\mathbf{y}_{NQ})
    \end{bmatrix},\]</p><p>for the <span>$\mathbf{H}$</span>-matrix. The approximation itself is based on the fact that subblocks of the matrix is well approximated by low-rank matrices. In this library all <span>$\mathcal{H}$</span>-matrix computations is done using the <a href="https://github.com/WaveProp/HMatrices.jl">HMatrices.jl</a> package developed by Luiz M. Faria. The specific format implemented in this library is the standard that the scales <span>$O(n\text{log}(n))$</span> in terms of memory and computation. At the same some experimentation of the newly developed Interpolated Factored Green&#39;s Function (IFGF) approach using the <a href="https://github.com/WaveProp/IFGF.jl">IFGF.jl</a> package also developed by Luiz. Note, that an often mentioned strength of the <span>$\mathcal{H}$</span>-matrix approach is that it is possible to compute the LU-factorization of the matrix efficiently, which is particularly important for high-frequency problems where an iterative solver might have issue converging. However, in the case of collocation BEM an LU-factorization can not directly be applied. Worse so when dealing with losses where the linear system of equation is a collection of matrix products.</p></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../">« Home</a><a class="docs-footer-nextpage" href="../2d_kernels/">Kernels »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 0.27.25 on <span class="colophon-date" title="Monday 10 July 2023 13:54">Monday 10 July 2023</span>. Using Julia version 1.8.5.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
