<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Background Theory · BoundaryIntegralEquations.jl</title><script data-outdated-warner src="../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.045/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.13.24/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../assets/documenter.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit"><a href="../">BoundaryIntegralEquations.jl</a></span></div><form class="docs-search" action="../search/"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li><a class="tocitem" href="../">Home</a></li><li class="is-active"><a class="tocitem" href>Background Theory</a><ul class="internal"><li><a class="tocitem" href="#Getting-the-computer-to-understand-functions"><span>Getting the computer to understand functions</span></a></li><li><a class="tocitem" href="#What-is-an-element?"><span>What is an element?</span></a></li><li><a class="tocitem" href="#Quadrature"><span>Quadrature</span></a></li><li><a class="tocitem" href="#The-Boundary-Element-Method"><span>The Boundary Element Method</span></a></li><li><a class="tocitem" href="#The-Fast-Multipole-Method-and-BEM"><span>The Fast Multipole Method and BEM</span></a></li><li><a class="tocitem" href="#\\mathcal{H}-Matrices"><span><span>$\mathcal{H}$</span>-Matrices</span></a></li><li><a class="tocitem" href="#Bibliography"><span>Bibliography</span></a></li></ul></li><li><a class="tocitem" href="../theory_rosebem/">ROSEBEM Theory</a></li><li><a class="tocitem" href="../theory_lossy/">Viscothermal Losses Theory</a></li><li><span class="tocitem">Examples</span><ul><li><input class="collapse-toggle" id="menuitem-5-1" type="checkbox"/><label class="tocitem" for="menuitem-5-1"><span class="docs-label">3D</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../examples/3d_lossy_sphere/">Lossy Oscilating sphere (Exterior)</a></li><li><a class="tocitem" href="../examples/3d_rosebem/">ROSEBEM: Rigid sphere scattering</a></li><li><a class="tocitem" href="../examples/3d_rigid_sphere/">Rigid sphere scattering (Exterior)</a></li><li><a class="tocitem" href="../examples/3d_oscilating_sphere/">Oscilating sphere (Interior)</a></li><li><a class="tocitem" href="../examples/3d_pulsating_sphere/">Pulsating sphere (Interior)</a></li><li><a class="tocitem" href="../examples/3d_cube_wave/">Cube with vibrating sides (Interior)</a></li><li><a class="tocitem" href="../examples/3d_cube_wave_anechoic/">Cube with anechoic condition (Interior)</a></li><li><a class="tocitem" href="../examples/3d_element_usage/">Surface Functions</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-5-2" type="checkbox"/><label class="tocitem" for="menuitem-5-2"><span class="docs-label">2D</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../examples/2d_infinite_cylinder/">Scattering of infinite cylinder</a></li><li><a class="tocitem" href="../examples/2d_element_usage/">Curve Functions</a></li></ul></li></ul></li><li><span class="tocitem">Internals</span><ul><li><input class="collapse-toggle" id="menuitem-6-1" type="checkbox"/><label class="tocitem" for="menuitem-6-1"><span class="docs-label">3D</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../3d_kernels/">Kernels</a></li><li><a class="tocitem" href="../3d_elements/">Element Types</a></li><li><a class="tocitem" href="../3d_meshes/">Meshes</a></li><li><a class="tocitem" href="../3d_fast_operators/">Fast Operators</a></li><li><a class="tocitem" href="../3d_losses/">Viscous and Thermal Losses</a></li><li><a class="tocitem" href="../3d_rosebem/">ROSEBEM</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-6-2" type="checkbox"/><label class="tocitem" for="menuitem-6-2"><span class="docs-label">2D</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../2d_kernels/">Kernels</a></li><li><a class="tocitem" href="../2d_elements/">Element Types</a></li><li><a class="tocitem" href="../2d_meshes/">Meshes</a></li></ul></li></ul></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href>Background Theory</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Background Theory</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/mipals/BoundaryIntegralEquations.jl/blob/main/docs/src/theory_background.md" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="Theoretical-Background"><a class="docs-heading-anchor" href="#Theoretical-Background">Theoretical Background</a><a id="Theoretical-Background-1"></a><a class="docs-heading-anchor-permalink" href="#Theoretical-Background" title="Permalink"></a></h1><p>This page includes the (some of) theoretical foundations of <code>BoundaryIntegralEquations.jl</code>.</p><h2 id="Getting-the-computer-to-understand-functions"><a class="docs-heading-anchor" href="#Getting-the-computer-to-understand-functions">Getting the computer to understand functions</a><a id="Getting-the-computer-to-understand-functions-1"></a><a class="docs-heading-anchor-permalink" href="#Getting-the-computer-to-understand-functions" title="Permalink"></a></h2><p>In the most basic terms, computers are only capable of understanding numbers, which means that they are inherently unable to solve equations where the unknowns are functions. This is a problem when trying to solve BIEs. To solve this problem, the functions are instead approximated using parameterizations for which the coefficients (numbers) are unknown. Intuitively, these numbers are exactly what the computer is asked to find. For element methods, this parameterization is chosen to be the simplest possible: A linear combination of functions</p><p class="math-container">\[p(\mathbf{x}) \approx \mathbf{T}(\mathbf{x})\mathbf{p} 
    = 
    \begin{bmatrix} T_1(\mathbf{x}) &amp;  T_2(\mathbf{x}) &amp;  \dots  &amp;  T_n(\mathbf{x}) \end{bmatrix}
    \begin{bmatrix} p_1             \\ p_2             \\ \vdots \\ p_n             \end{bmatrix}. \]</p><p>where <span>$p$</span> is the unknown function being approximated. Note that the linearity is with respect to the unknown parameters <span>$\mathbf{p}$</span>, but not necessarily in the known basis functions <span>$\mathbf{T}(\mathbf{x})$</span>. A useful, but not necessary, property is called the Cardinal property stating that </p><p class="math-container">\[T_i(\mathbf{x}_j) = \delta_{ij} = 
    \begin{cases}
        1, \quad i = j\\
        0, \quad i \neq j    
    \end{cases}.\]</p><p>The usefulness is due the property making the <span>$j$</span>th value of <span>$\mathbf{p}$</span> interpretable as the value of the function at point <span>$\mathbf{x}_j$</span> as</p><p class="math-container">\[\mathbf{T}(\mathbf{x}_j)\mathbf{p} = p_j.\]</p><p>One might ask: <em>How does the above relate to The Boundary Element Method?</em> The answer is that the functions <span>$\mathbf{T}_i$</span> are chosen to be simpler functions with support equal to only a few subdomains of the original domain. These subdomains are commonly referred to as elements. </p><h2 id="What-is-an-element?"><a class="docs-heading-anchor" href="#What-is-an-element?">What is an element?</a><a id="What-is-an-element?-1"></a><a class="docs-heading-anchor-permalink" href="#What-is-an-element?" title="Permalink"></a></h2><p>A key insight is that the element serves two purposes: It represents a subdomain of the original domain (also referred to as the geometry) while also describing parts of the unknown function(s) of interest. In the case of surface elements, which are the ones used for BEMs, the parameterization of the subdomain, i.e. the element, is done as</p><p class="math-container">\[    \mathbf{x}^e(\mathbf{u}) = \mathbf{X}^e\mathbf{N}^e(\mathbf{u}) \in \Gamma^e, \quad \forall \mathbf{u} \in \mathcal{L}^e,\]</p><p>where the superscript <span>$e$</span> denotes the element number, <span>$\mathbf{x}^e$</span> is a matrix with columns equal to the interpolation nodes of the geometry, <span>$\mathbf{N}^e(\mathbf{u})$</span> are the so-called shape functions, <span>$\Gamma^e$</span> is the element in global coordinates and <span>$\mathcal{L}^e$</span> are the local coordinates. The structure of some collection of interpolation nodes (<span>$\mathbf{X}^e$</span>) multiplied by some shape function (<span>$\mathbf{N}^e(\mathbf{u})$</span>) is the same for most geometric elements. For BEMs in 3D, it is common to work with triangular elements, which can be seen in the Figure below. In particular, the elements in \autoref{fig:sfd:geom} are linear, for which a description can be found in the Example.</p><p><img src="../figures/shape_function.png" alt="Elements"/></p><div class="admonition is-info"><header class="admonition-header">Example: Linear triangular elements</header><div class="admonition-body"><p>The linear shape functions for a triangular element can have the form</p><p class="math-container">\[\begin{equation}
    \mathbf{X}^e(u_1,u_2) = 
    \begin{bmatrix}
        1 - u_1 - u_2 \\ u_1 \\ u_2
    \end{bmatrix}, \quad u_1\in[0, 1],\ u_2\in[0, 1-u_1].
\end{equation}\]</p><p>The choice in the wording can is because the ordering of the columns of <span>$\mathbf{X}^e$</span> can change the ordering rows of <span>$\mathbf{N}^e(\mathbf{u})$</span> or vice versa. This is something that one should keep in mind in practice when using different mesh file formats. Taking the second element of Figure above as an example, it could be that </p><p class="math-container">\[\begin{equation}
    \mathbf{X}^2 = \begin{bmatrix} \mathbf{x}_3 &amp; \mathbf{x}_1 &amp; \mathbf{x}_4 \end{bmatrix}.
\end{equation}\]</p><p>Note that extending the geometric interpolation to higher orders is as simple as adding more rows/functions to <span>$\mathbf{N}^e(u_1,u_2)$</span> as well as more columns/points to <span>$\mathbf{X}^e$</span>. </p></div></div><p>In addition to the geometric interpolation of each element, we need to further define interpolations of the unknown functions, which in the case of the Kirchhoff-Helmholtz equation is <span>$p(\mathbf{x})$</span> and <span>$v_\mathbf{n}(\mathbf{x})$</span>. Taking <span>$p(\mathbf{x})$</span> as an example, we find that on element <span>$e$</span> this interpolation can be done as</p><p class="math-container">\[    p(\mathbf{x}^e(\mathbf{u})) = \mathbf{T}(\mathbf{x}^e(\mathbf{u}))\mathbf{p} = \underbrace{\mathbf{T}(\mathbf{x}(\mathbf{u}))(\mathbf{L}^e)^\top}_{\mathbf{T}^e(\mathbf{u})}\underbrace{\mathbf{L}^e\mathbf{p}}_{\mathbf{p}^e} = \mathbf{T}^e(u)\mathbf{p}^e, \quad \mathbf{u} \in \mathcal{L}^e\]</p><p>where <span>$\mathbf{L}^e$</span> is a permutation-like matrix that extracts the relevant values of <span>$\mathbf{p}$</span> and orders them such that they correspond to the local basis functions of <span>$\mathbf{T}^e(\mathbf{u})$</span>. The local basis functions are usually chosen as Lagrange polynomials, but other basis functions, such as, e.g., Legendre polynomials and splines, have also been successfully applied <a href="#beer2020a">[1]</a>. The figures and examples below show the interpolation on triangular elements in the case of continuous interpolation and discontinuous interpolation. In short, the difference between continuous and discontinuous interpolations is that the interpolation nodes <span>$\mathbf{p}^e$</span> are shared between multiple elements (continuous elements) or completely inside the element (discontinuous elements). A consequence of the position of the interpolation nodes is that the value on the shared edge, highlighted in blue in both figures, is uniquely defined for continuous elements, while it serves as a discontinuity for discontinuous elements. </p><p><img src="../figures/interpolation_continuous.png" alt="Elements"/> <img src="../figures/interpolation_discontinuous.png" alt="Elements"/></p><div class="admonition is-info"><header class="admonition-header">Example: Basis functions for linear interpolation</header><div class="admonition-body"><p>Continuous linear basis functions on triangular elements are similar to shape functions for a linear triangular element and differ only in the fact that it is the transpose.</p><p class="math-container">\[\begin{equation}
    \mathbf{T}^e_\text{continuous}(u_1,u_2) = 
    \begin{bmatrix}
        1 - u_1 - u_2 &amp; u_1 &amp; u_2
    \end{bmatrix}, \quad u_1\in[0, 1],\ u_2\in[0, 1-u_1],
\end{equation}\]</p><p>where the subscript &quot;continuous&quot; is only there to highlight that it is a continuous formulation. Again, the ordering of the columns of the row vector depends on the ordering of the element corners. The discontinuous linear interpolation is simply a scaled continuous formulation</p><p class="math-container">\[\begin{equation}
    \mathbf{T}^e_\text{discontinuous}(u_1,u_2) = \mathbf{T}^e_\text{continuous}\left(\frac{u_1 - \beta}{1-3\beta},\frac{u_2 - \beta}{1 - 3\beta}\right),
\end{equation}\]</p><p>where <span>$\beta \in \left[0,\frac{1}{2}\right[$</span> is a scalar representing the location of the interpolation nodes in the local <span>$\mathcal{L}^e$</span> coordinates.</p></div></div><div class="admonition is-info"><header class="admonition-header">Example: Element Localization Matrix</header><div class="admonition-body"><p>For a continuous linear element <span>$e$</span> all three corners correspond to a value of the global vector <span>$\mathbf{p}$</span>. For example, the second element in continuous plot has local corner values given by <span>$\mathbf{p}^2 = \begin{bmatrix}p_3 &amp; p_1 &amp; p_4 \end{bmatrix}^\top$</span>. This element would have <span>$\mathbf{L}^e$</span> given as</p><p class="math-container">\[\begin{equation}
    \mathbf{L}^2 = 
    \begin{bmatrix}
        0 &amp; 0 &amp; 1 &amp; 0 &amp; \dots &amp; 0\\
        1 &amp; 0 &amp; 0 &amp; 0 &amp; \dots &amp; 0\\
        0 &amp; 0 &amp; 0 &amp; 1 &amp; \dots &amp; 0
    \end{bmatrix},
\end{equation}\]</p><p>so that <span>$\mathbf{p}^2 = \mathbf{L}^2\mathbf{p}$</span>. Note that <span>$\mathbf{L}^e$</span> is only an artifact of the mathematical description. Any reasonable implementation should use indexing instead of multiplication with <span>$\mathbf{L}^e$</span>.</p><p>In the case of the discontinuous description the same element in discontinuous plot would have <span>$\mathbf{p}^2 = \begin{bmatrix}p_4 &amp; p_5 &amp; p_6\end{bmatrix}^\top$</span> meaning that</p><p class="math-container">\[\begin{equation}
    \mathbf{L}^2 = 
    \begin{bmatrix}
        0 &amp; 0 &amp; 0 &amp; 1 &amp; 0 &amp; 0 &amp; 0 &amp; \dots &amp; 0\\
        0 &amp; 0 &amp; 0 &amp; 0 &amp; 1 &amp; 0 &amp; 0 &amp; \dots &amp; 0\\
        0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; 1 &amp; 0 &amp; \dots &amp; 0
    \end{bmatrix}.
\end{equation}\]</p><p>Note here that the discontinuous nature result in <span>$\mathbf{L}^e$</span> simply picks out three consecutive values. </p></div></div><div class="admonition is-info"><header class="admonition-header">Note: </header><div class="admonition-body"><p>The element localization matrix can also be used to define the geometric interpolation. Following a similar procedure as for the pressure, we can write the interpolation as</p><p class="math-container">\[\begin{equation}
    \mathbf{x}(\mathbf{u}) = \mathbf{X}\mathbf{N}(\mathbf{u}) = \underbrace{\mathbf{X}\left(\mathbf{L}^e\right)^\top}_{\mathbf{X}^e}\underbrace{\mathbf{L}^e\mathbf{N}(\mathbf{u})}_{\mathbf{N}^e(\mathbf{u})},
\end{equation}\]</p><p>where <span>$\mathbf{X}$</span> is a matrix whose columns contain all the interpolation nodes of the geometry and <span>$\mathbf{N}(\mathbf{u})$</span> are global basis functions. However, in practice, using this formulation does not give an advantage, as <span>$\mathbf{X}$</span> is fully known. This is opposed to the interpolation of functions for which both <span>$\mathbf{p}$</span> and <span>$\mathbf{v}_\mathbf{n}$</span> are unknown.</p></div></div><h2 id="Quadrature"><a class="docs-heading-anchor" href="#Quadrature">Quadrature</a><a id="Quadrature-1"></a><a class="docs-heading-anchor-permalink" href="#Quadrature" title="Permalink"></a></h2><p>As we will explore in the next section, the underlying mathematics of boundary element methods is that of boundary integrals. In most cases, it is not possible to compute these integrals analytically. Instead, a quadrature scheme is used to approximate the integrals. To do so, the boundary integrals in global coordinates are transformed into the local element coordinates. This transformation comes with the cost of the need to compute the so-called Jacobian function, which describes the local deformation from the transformation. For 2D and 3D this deformation looks as follows</p><p class="math-container">\[\begin{alignat*}{3}
    \text{2D:} &amp; \quad \text{jacobian}(u)   &amp;&amp;= \left\|\mathbf{X}^e \frac{\mathrm{d}\mathbf{N}^e(u)}{\mathrm{d}u}\right\|_2 \quad &amp;&amp; \text{(length deformation)}\\
    \text{3D:} &amp; \quad \text{jacobian}(u,v) &amp;&amp;= \left\|\left(\mathbf{X}^e \frac{\mathrm{d}\mathbf{N}^e(u,v)}{\mathrm{d}u}\right) \times \left(\mathbf{X}^e \frac{\mathrm{d}\mathbf{N}^e(u,v)}{\mathrm{d}v}\right) \right\|_2 \quad &amp;&amp; \text{(area deformation)}
\end{alignat*}\]</p><p>Applying this the surface integral can be transformed into local coordinates and approximated using a suitable quadrature scheme as</p><p class="math-container">\[    \int_{\Gamma^e} f(\mathbf{x})\ \mathrm{d}S_\mathbf{x} = \int_{\mathcal{L}^e} \text{jacobian}(\mathbf{u})f(\mathbf{u})\ \mathrm{d}\mathbf{u} \approx \sum_{i=1}^{Q} \text{jacobian}(\mathbf{u}_i)w_if(\mathbf{u}_i),\]</p><p>where <span>$\mathbf{u}_i$</span> is the <span>$i$</span>th quadrature point with corresponding weights <span>$w_i$</span>.</p><h2 id="The-Boundary-Element-Method"><a class="docs-heading-anchor" href="#The-Boundary-Element-Method">The Boundary Element Method</a><a id="The-Boundary-Element-Method-1"></a><a class="docs-heading-anchor-permalink" href="#The-Boundary-Element-Method" title="Permalink"></a></h2><p>In simple terms, the boundary element method is a method for solving boundary integral equations through a discretization of both the unknown function and the domain <a href="#Marburg2017">[2]</a>. In this software, the main focus is solving the so-called Kirchhoff-Helmholtz integral equation</p><p class="math-container">\[\int_\Gamma \phi(\mathbf{x}) \left(\zeta(\mathbf{x})p(\mathbf{x}) + \int_\Gamma \frac{\partial G(\mathbf{x}, \mathbf{y})}{\partial \mathbf{n}(\mathbf{y})}p(\mathbf{y})\ \mathrm{d}S_\mathbf{y} -
    \mathrm{i} \rho_0 c k \int_\Gamma G(\mathbf{x},\mathbf{y})v_\mathbf{n}(\mathbf{y})\ \mathrm{d}S_\mathbf{y}\right)\ \mathrm{d}S_\mathbf{x} = 0.\]</p><p>where </p><p class="math-container">\[    G(\mathbf{x},\mathbf{y}) = \frac{\exp\left(\mathrm{i}k\|\mathbf{x} - \mathbf{y}\|_2\right)}{4\pi\|\mathbf{x} - \mathbf{y}\|_2},\]</p><p>is the Green&#39;s function of the Helmholtz operator, <span>$k$</span> is the wavenumber, <span>$\rho_0$</span> is the ambient density, <span>$c$</span> is the speed of sound, <span>$\phi(\mathbf{x})$</span> is a so-called test function, and <span>$\zeta(\mathbf{x})$</span> is the integral free term depending only on the geometry at point <span>$\mathbf{x}$</span>. When <span>$\mathbf{x}$</span> is located on a smooth part of the surface <span>$\zeta(\mathbf{x})$</span> is equal to <span>$\frac{1}{2}$</span>, but otherwise fluctuates between 0 and 1.</p><p>The approach implemented is the so-called collocation approach. This approach is based where the test function is equal to the sum of Dirac-delta functions centered around each of the collocation points, that is,</p><p class="math-container">\[\phi(\mathbf{x}) =  \mathbf{a}^\top
                    \begin{bmatrix}
                        \delta\left(\mathbf{x} - \mathbf{t}_1\right)\\ 
                        \delta\left(\mathbf{x} - \mathbf{t}_2\right)\\ 
                        \vdots\\
                        \delta\left(\mathbf{x} - \mathbf{t}_n\right)\\ 
                    \end{bmatrix},\]</p><p>where <span>$\mathbf{a} \in \mathbb{C}^n$</span> is a vector of arbitrary coefficients and <span>$\mathbf{t}_i \in \mathbb{R}^3$</span> are the nodal mesh positions (target points). </p><p class="math-container">\[\mathbf{a}^\top
\begin{bmatrix}
    c(\mathbf{t}_1)p(\mathbf{t}_1)\\ 
    c(\mathbf{t}_2)p(\mathbf{t}_2)\\ 
    \vdots \\ 
    c(\mathbf{t}_n)p(\mathbf{t}_n)
\end{bmatrix} 
+ 
\mathbf{a}^\top
\begin{bmatrix}
    \int_\Gamma\frac{\partial G(\mathbf{t}_1, \mathbf{y})}{\partial\mathbf{n}(\mathbf{y})}p(\mathbf{y})\ \mathrm{d}S_\mathbf{y}\\
    \int_\Gamma\frac{\partial G(\mathbf{t}_2, \mathbf{y})}{\partial\mathbf{n}(\mathbf{y})}p(\mathbf{y})\ \mathrm{d}S_\mathbf{y}\\
    \vdots \\
    \int_\Gamma\frac{\partial G(\mathbf{t}_n, \mathbf{y})}{\partial\mathbf{n}(\mathbf{y})}p(\mathbf{y})\ \mathrm{d}S_\mathbf{y}
\end{bmatrix}
=
\mathbf{a}^\top
\begin{bmatrix}
    \mathrm{i} \rho_0 c k\int_\Gamma G(\mathbf{t}_1, \mathbf{y})v_\mathbf{n}(\mathbf{y})\ \mathrm{d}S_\mathbf{y}\\
    \mathrm{i} \rho_0 c k\int_\Gamma G(\mathbf{t}_2, \mathbf{y})v_\mathbf{n}(\mathbf{y})\ \mathrm{d}S_\mathbf{y}\\
    \vdots \\
    \mathrm{i} \rho_0 c k\int_\Gamma G(\mathbf{t}_n, \mathbf{y})v_\mathbf{n}(\mathbf{y})\ \mathrm{d}S_\mathbf{y}
\end{bmatrix}.\]</p><p>In its current form the solution to the above equation is a <em>function</em> which a computer can not be tasked to find. Instead, the problem is made computationally tractable by parametrizing the functions <span>$p$</span> and <span>$v_\mathbf{n}$</span> as shown previously. As such the above reduces to</p><p class="math-container">\[\mathbf{a}^\top
\begin{bmatrix}
    c(\mathbf{t}_1)\mathbf{T}(\mathbf{t}_1)\mathbf{p}\\ 
    c(\mathbf{t}_2)\mathbf{T}(\mathbf{t}_2)\mathbf{p}\\ 
    \vdots \\ 
    c(\mathbf{t}_n)\mathbf{T}(\mathbf{t}_n)\mathbf{p}
\end{bmatrix}
+ 
\mathbf{a}^\top
\begin{bmatrix}
    \int_\Gamma\frac{\partial G(\mathbf{t}_1, \mathbf{y})}{\partial\mathbf{n}(\mathbf{y})}\mathbf{T}(\mathbf{y})\mathbf{p}\ \mathrm{d}S_\mathbf{y}\\
    \int_\Gamma\frac{\partial G(\mathbf{t}_2, \mathbf{y})}{\partial\mathbf{n}(\mathbf{y})}\mathbf{T}(\mathbf{y})\mathbf{p}\ \mathrm{d}S_\mathbf{y}\\
    \vdots \\
    \int_\Gamma\frac{\partial G(\mathbf{t}_n, \mathbf{y})}{\partial\mathbf{n}(\mathbf{y})}\mathbf{T}(\mathbf{y})\mathbf{p}\ \mathrm{d}S_\mathbf{y}
\end{bmatrix}
\approx
\mathbf{a}^\top
\begin{bmatrix}
    \mathrm{i} \rho_0 c k\int_\Gamma G(\mathbf{t}_1, \mathbf{y})\mathbf{T}(\mathbf{y})\mathbf{v}_\mathbf{n}\ \mathrm{d}S_\mathbf{y}\\
    \mathrm{i} \rho_0 c k\int_\Gamma G(\mathbf{t}_2, \mathbf{y})\mathbf{T}(\mathbf{y})\mathbf{v}_\mathbf{n}\ \mathrm{d}S_\mathbf{y}\\
    \vdots \\
    \mathrm{i} \rho_0 c k\int_\Gamma G(\mathbf{t}_n, \mathbf{y})\mathbf{T}(\mathbf{y})\mathbf{v}_\mathbf{n}\ \mathrm{d}S_\mathbf{y}
\end{bmatrix}.\]</p><p>By the cardinal property of the basis functions it follows that</p><p class="math-container">\[\mathbf{a}^\top
\left(
\text{diag}\left(\begin{bmatrix}
    c(\mathbf{t}_1)\\ 
    c(\mathbf{t}_2)\\ 
    \vdots \\ 
    c(\mathbf{t}_n)
\end{bmatrix}\right)
+ 
\begin{bmatrix}
    \int_\Gamma\frac{\partial G(\mathbf{t}_1, \mathbf{y})}{\partial\mathbf{n}(\mathbf{y})}\mathbf{T}(\mathbf{y})\ \mathrm{d}S_\mathbf{y}\\
    \int_\Gamma\frac{\partial G(\mathbf{t}_2, \mathbf{y})}{\partial\mathbf{n}(\mathbf{y})}\mathbf{T}(\mathbf{y})\ \mathrm{d}S_\mathbf{y}\\
    \vdots \\
    \int_\Gamma\frac{\partial G(\mathbf{t}_n, \mathbf{y})}{\partial\mathbf{n}(\mathbf{y})}\mathbf{T}(\mathbf{y})\ \mathrm{d}S_\mathbf{y}
\end{bmatrix}\right)\mathbf{p}
\approx
\mathbf{a}^\top
\begin{bmatrix}
    \mathrm{i} \rho_0 c k\int_\Gamma G(\mathbf{t}_1, \mathbf{y})\mathbf{T}(\mathbf{y})\ \mathrm{d}S_\mathbf{y}\\
    \mathrm{i} \rho_0 c k\int_\Gamma G(\mathbf{t}_2, \mathbf{y})\mathbf{T}(\mathbf{y})\ \mathrm{d}S_\mathbf{y}\\
    \vdots \\
    \mathrm{i} \rho_0 c k\int_\Gamma G(\mathbf{t}_n, \mathbf{y})\mathbf{T}(\mathbf{y})\ \mathrm{d}S_\mathbf{y}
\end{bmatrix}\mathbf{v}_\mathbf{n}.\]</p><p>Since the above has to hold for all <span>$\mathbf{a} \in \mathbb{C}^n$</span> it follows that</p><p class="math-container">\[\left(\text{diag}\left(\begin{bmatrix}
    c(\mathbf{t}_1)\\ 
    c(\mathbf{t}_2)\\ 
    \vdots \\ 
    c(\mathbf{t}_n)
\end{bmatrix}\right)
+ 
\mathbf{F}\right)\mathbf{p}
=
\mathrm{i} \rho_0 c k\mathbf{G}\mathbf{v}_\mathbf{n}.\]</p><p>For simplification purposes the above is sometimes written as</p><p class="math-container">\[\mathbf{H}\mathbf{p} + \mathbf{G}\partial_\mathbf{n}\mathbf{p} = \mathbf{0}.\]</p><p>We now briefly explain how to compute the <span>$k$</span>th row of <span>$\mathbf{F}$</span>. To do so element description of the unknown functions is used</p><p class="math-container">\[\begin{equation}
    p(\mathbf{y}^e(\mathbf{u})) \approx \mathbf{T}(\mathbf{y})\mathbf{p} = \underbrace{\mathbf{T}(\mathbf{y}^e(\mathbf{u}))(\mathbf{L}^e)^\top}_{\mathbf{T}^e(\mathbf{u})}\mathbf{L}^e\mathbf{p}
\end{equation}\]</p><p>Inserting this it follows that</p><p class="math-container">\[\begin{aligned}
\int_\Gamma\frac{\partial G(\mathbf{t}_k, \mathbf{y})}{\partial\mathbf{n}(\mathbf{y})}\mathbf{T}(\mathbf{y})\mathbf{p}\ \mathrm{d}S_\mathbf{y} 
&amp;\approx \sum_{e=1}^{N}\left(\int_{\Gamma^e}\frac{\partial G(\mathbf{t}_k, \mathbf{y})}{\partial\mathbf{n}(\mathbf{y})}\mathbf{T}(\mathbf{y})(\mathbf{L}^e)^\top\mathbf{L}^e\ \mathrm{d}S_\mathbf{y}\right) \mathbf{p}\\
&amp;\approx \left(\underbrace{\sum_{e=1}^{N}\left(\sum_{i=1}^{Q(\mathbf{z}_j,e)}\frac{\partial G(\mathbf{t}_k, \mathbf{y}^e(\mathbf{u}_i))}{\partial\mathbf{n}(\mathbf{y}^e(\mathbf{u}_i))}\text{jacobian}(\mathbf{u}_i)w_i\mathbf{T}^e(\mathbf{u}_i)\right)\mathbf{L}^e}_{j\text{th row of }\mathbf{F}}\right)\mathbf{p},
\end{aligned}\]</p><p>where the number of quadrature points, <span>$Q(\mathbf{t}_k,e)$</span>, is depended on element location with respect to the collocation point <span>$\mathbf{t}_k$</span>. Note that approximation in the first line of the above is due to approximation of the geometry using elements while the second approximation is due to the integration error. A similar approach can be applied for the rows of <span>$\mathbf{G}$</span>.</p><p>A downside of the BEM is that the resulting matrices <span>$\mathbf{H}, \mathbf{G} \in \mathbb{C}^{n\times n}$</span> are dense, meaning that storing the two matrices scales as <span>$\mathcal{O}(n^2)$</span> rendering the direct application of the method unusable large <span>$n$</span>.</p><h2 id="The-Fast-Multipole-Method-and-BEM"><a class="docs-heading-anchor" href="#The-Fast-Multipole-Method-and-BEM">The Fast Multipole Method and BEM</a><a id="The-Fast-Multipole-Method-and-BEM-1"></a><a class="docs-heading-anchor-permalink" href="#The-Fast-Multipole-Method-and-BEM" title="Permalink"></a></h2><p>The Fast Multipole Method (FMM) can be used to accelerate the multiplication with the BEM matrices <span>$\mathbf{H}$</span> and <span>$\mathbf{G}$</span>. Throughout the years many good resources that explain the intricacies of the FMM have been written. As such the details will here be left out. Instead, the focus will be on how to apply a 3rd-party FMM into an existing BEM framework. As an example the focus will be on the <em>Flatiron Institute Fast Multipole Libraries</em> <a href="#fmm3d">[3]</a>, as this is the library currently interfaced in <code>BoundaryIntegralEquations.jl</code>. This library can be used to accelerate sums of the following form from <span>$O(NQ)$</span> to <span>$O(\text{log}(NQ))$</span></p><p class="math-container">\[    u(\mathbf{t}_k) = \sum_{j=1}^{NQ}G(\mathbf{t}_k,\mathbf{y}_j)c_j, \quad 
    u(\mathbf{t}_k) = \sum_{j=1}^{NQ}\mathbf{n}(\mathbf{y}_j)^\top\nabla G(\mathbf{t}_k,\mathbf{y}_j)c_j\]</p><p>where the <span>$j$</span>th term is excluded from the sum if <span>$\mathbf{t}_k = \mathbf{y}_j$</span>. The question is now: <em>How can this be used to speed up multiplication with the BEM matrices?</em></p><p>To see how we start by simplifying things by assuming that each element requires the same amount of quadrature points (this will cause numerical issues that are then fixed by a nearfield correction step), <span>$Q$</span>, and that we want to multiply with a known vector <span>$\mathbf{z}$</span>. Then for a row of <span>$\mathbf{G}$</span> we have that</p><p class="math-container">\[\begin{aligned}
    \left(\underbrace{\int_\Gamma G(\mathbf{t}_k,\mathbf{y})\mathbf{T}(\mathbf{y})\ \mathrm{d}S_\mathbf{y}}_{k\text{th row of } \mathbf{G}}\right)\mathbf{z}
    &amp;\approx
    \left(\sum_{e=1}^{N}\left(\sum_{i=1}^{Q}G(\mathbf{t}_k, \mathbf{y}^e(\mathbf{u}_i))\text{jacobian}(\mathbf{u}_i)w_i\mathbf{T}^e(\mathbf{u}_i)\right)\mathbf{L}^e\right)\mathbf{z}\\
    &amp;= \left(\sum_{j=1}^{NQ}G(\mathbf{t}_k, \mathbf{y}_j)\underbrace{\text{jacobian}(\mathbf{u}_j)w_j\mathbf{T}^{e(j)}(\mathbf{u}_j)\mathbf{L}^{e(j)}}_{j\text{th row of } \mathbf{C}}\right)\mathbf{z}\\
    &amp;= 
    \begin{bmatrix}
        G(\mathbf{t}_k, \mathbf{y}_1) &amp; G(\mathbf{t}_k, \mathbf{y}_2,) &amp; \dots &amp; G(\mathbf{t}_k, \mathbf{y}_{NQ})
    \end{bmatrix}
    \mathbf{C}\mathbf{z}
\end{aligned}\]</p><p>where the subscript <span>$j$</span> refers to an ordering of the collection of Gaussian points from all elements and <span>$e(j)$</span> is a function that returns the element number that Gaussian point <span>$j$</span> is located on. Furthermore, the matrix <span>$\mathbf{C}$</span> can be thought of as a transformation from <span>$\mathbf{z}$</span> into the coefficients <span>$4\pi c_j$</span>. A similar approach can be applied to <span>$\mathbf{H}$</span></p><p class="math-container">\[\begin{aligned}
    \left(\underbrace{\int_\Gamma\frac{\partial G(\mathbf{t}_k, \mathbf{y})}{\partial\mathbf{n}(\mathbf{y})}\mathbf{T}(\mathbf{y})\ \mathrm{d}S_\mathbf{y}}_{k\text{th row of } \mathbf{F}}\right)\mathbf{y}
    &amp;\approx 
    \left(\sum_{e=1}^{N}\left(\sum_{i=1}^{Q}\frac{\partial G(\mathbf{t}_k, \mathbf{y}^e(\mathbf{u}_i))}{\partial\mathbf{n}(\mathbf{y})}\text{jacobian}(\mathbf{u}_i)w_i\mathbf{T}^e(\mathbf{u}_i)\right)\mathbf{L}^e\right)\mathbf{z}\\
    &amp;= \left(\sum_{j=1}^{NQ}\nabla G(\mathbf{t}_k, \mathbf{y}_j)\cdot \mathbf{n}(\mathbf{y}_j)\underbrace{\text{jacobian}(\mathbf{u}_j)w_j\mathbf{T}^{e(j)}(\mathbf{u}_j)\mathbf{L}^{e(j)}}_{j\text{th row of }\mathbf{C}}\right)\mathbf{z}\\
    &amp;= 
    \begin{bmatrix}
        \nabla G(\mathbf{t}_k, \mathbf{y}_1)\cdot \mathbf{n}(\mathbf{y}_1) &amp;
        \dots &amp;
        \nabla G(\mathbf{t}_k, \mathbf{y}_{NQ})\cdot \mathbf{n}(\mathbf{y}_{NQ})
    \end{bmatrix}
    \mathbf{C}\mathbf{z},
\end{aligned}\]</p><p>where <span>$\mathbf{C}$</span> is a matrix that transforms <span>$\mathbf{z}$</span> into the coefficients <span>$4\pi v_j$</span>. The two equations highlights how the FMM can be applied for problems where the number of Gaussian points on each element is equal. However, in practical cases this approach will be victim to numerical instabilities due to numerical errors stemming from the integration of elements close to the collocation point. To resolve this issue the BEM matrices is split into parts</p><p class="math-container">\[        \mathbf{A} = \mathbf{B}\mathbf{C} + \mathbf{S}, \quad \mathbf{G} \in\mathbb{C}^{n\times NQ},\ \mathbf{S}\in\mathbb{C}^{n\times n},\ \mathbf{C}\in\mathbb{R}^{NQ\times n}.\]</p><p>Here <span>$\mathbf{B}$</span> is the part approximated by the FMM (using <span>$Q$</span> Gaussian points on each element), <span>$\mathbf{C}$</span> is the coefficient mapping, and <span>$\mathbf{S}$</span> the nearfield correction. In short the nearfield correction subtract the wrong integration done by using only <span>$Q$</span> Gaussian points and adds on the correct integration instead. It is important to note that <span>$\mathbf{S}$</span> and <span>$\mathbf{C}$</span> are both highly sparse matrices, meaning that both assembly and multiplication with these scale <span>$\mathcal{O}(n\tau)$</span> where <span>$\tau \ll n$</span>. This means that using an approximate scheme for <span>$\mathbf{B}$</span> with a multiplication that scales linear in time and memory result in a representation of <span>$\mathbf{A}$</span> that scales similarly.</p><p><img src="../figures/nearfield_correction.png" alt="Nearfield Correction"/></p><h2 id="\\mathcal{H}-Matrices"><a class="docs-heading-anchor" href="#\\mathcal{H}-Matrices"><span>$\mathcal{H}$</span>-Matrices</a><a id="\\mathcal{H}-Matrices-1"></a><a class="docs-heading-anchor-permalink" href="#\\mathcal{H}-Matrices" title="Permalink"></a></h2><p>The <span>$\mathcal{H}$</span>-matrix approach differs from the FMM by the fact that it does not accelerate the sums directly. Instead, it approximates parts of the matrix that corresponds to performing the integration for all the <span>$n$</span> collocation points at the same time. In particular, it approximates the <span>$\mathbf{B}$</span> part of the BE matrix split as</p><p class="math-container">\[\mathbf{B} = 
    \begin{bmatrix}
        G(\mathbf{x}_1,\mathbf{y}_1)  &amp; G(\mathbf{x}_1,\mathbf{y}_2) &amp; \dots    &amp; G(\mathbf{x}_1,\mathbf{y}_{NQ}) \\
        G(\mathbf{x}_2,\mathbf{y}_1)  &amp; G(\mathbf{x}_2,\mathbf{y}_2) &amp; \dots    &amp; G(\mathbf{x}_2,\mathbf{y}_{NQ}) \\
        \vdots          &amp; \vdots         &amp; \ddots   &amp; \vdots            \\
        G(\mathbf{x}_n,\mathbf{y}_1)  &amp; G(\mathbf{x}_n,\mathbf{y}_2) &amp; \dots    &amp; G(\mathbf{x}_n,\mathbf{y}_{NQ})
    \end{bmatrix},\]</p><p>for the <span>$\mathbf{G}$</span>-matrix and as</p><p class="math-container">\[ \mathbf{B} = 
    \begin{bmatrix}
        \mathbf{n}(\mathbf{y}_1)^\top G(\mathbf{x}_1,\mathbf{y}_1)  &amp; \mathbf{n}(\mathbf{y}_2)^\top G(\mathbf{x}_1,\mathbf{y}_2) &amp; \dots    &amp; \mathbf{n}(\mathbf{y}_{NQ})^\top G(\mathbf{x}_1,\mathbf{y}_{NQ})\\
        \mathbf{n}(\mathbf{y}_1)^\top G(\mathbf{x}_2,\mathbf{y}_1)  &amp; \mathbf{n}(\mathbf{y}_2)^\top G(\mathbf{x}_2,\mathbf{y}_2) &amp; \dots    &amp; \mathbf{n}(\mathbf{y}_{NQ})^\top G(\mathbf{x}_2,\mathbf{y}_{NQ})\\
        \vdots                          &amp; \vdots                         &amp; \ddots   &amp; \vdots \\
        \mathbf{n}(\mathbf{y}_1)^\top G(\mathbf{x}_n,\mathbf{y}_1)  &amp; \mathbf{n}(\mathbf{y}_2)^\top G(\mathbf{x}_n,\mathbf{y}_2) &amp; \dots    &amp; \mathbf{n}(\mathbf{y}_{NQ})^\top G(\mathbf{x}_n,\mathbf{y}_{NQ})
    \end{bmatrix},\]</p><p>for the <span>$\mathbf{F}$</span>-matrix. The approximation itself is based on the fact that subblocks of the matrix is well approximated by low-rank matrices. In this library all <span>$\mathcal{H}$</span>-matrix computations is done using the <a href="https://github.com/WaveProp/HMatrices.jl">HMatrices.jl</a> package developed by Luiz M. Faria [hmatrices][@cite]. The specific format implemented in this library is the standard that the scales <span>$O(n\text{log}(n))$</span> in terms of memory and computation. At the same some experimentation of the newly developed Interpolated Factored Green&#39;s Function (IFGF) <a href="#bauinger2021a">[4]</a> approach using the <a href="https://github.com/WaveProp/IFGF.jl">IFGF.jl</a> package also developed by Luiz <a href="#ifgf">[5]</a>. Note, that an often mentioned strength of the <span>$\mathcal{H}$</span>-matrix approach is that it is possible to compute the LU-factorization of the matrix efficiently, which is particularly important for high-frequency problems where an iterative solver might have issue converging. However, in the case of collocation BEM an LU-factorization can not directly be applied. Worse so when dealing with losses where the linear system of equation is a collection of matrix products.</p><h2 id="Bibliography"><a class="docs-heading-anchor" href="#Bibliography">Bibliography</a><a id="Bibliography-1"></a><a class="docs-heading-anchor-permalink" href="#Bibliography" title="Permalink"></a></h2><div class="citation canonical"><dl><dt>[1]</dt>
<dd>
<div id="beer2020a">G. Beer, B. Marussig and C. Duenser. <i>The Isogeometric Boundary Blement Method</i>. <a href='https://doi.org/10.1007/978-3-030-23339-6_1'>Springer Verlag (2020)</a>.</div>
</dd><dt>[2]</dt>
<dd>
<div id="Marburg2017">S. Marburg. <i>Boundary Element Method for Time–Harmonic Acoustic Problems</i>. <a href='https://doi.org/https://doi.org/10.1007/978-3-319-59038-7_3'>In Computational Acoustics, editors, Manfred Kaltenbacher, 69–159. Springer (2017)</a>.</div>
</dd><dt>[3]</dt>
<dd>
<div id="fmm3d">T. Askham, Z. Gimbutas, L. Greengard, L. Lu, J. Magland, D. Malhotra, M. O'Neil, M. Rachh and V. Rohklin. <i>FMM3D</i>. <a href='https://github.com/flatironinstitute/FMM3D'> (2023)</a>.</div>
</dd><dt>[4]</dt>
<dd>
<div id="bauinger2021a">C. Bauinger and O. P. Bruno. <i>“Interpolated Factored Green Function” Method for accelerated solution of Scattering Problems</i>. <a href='https://doi.org/10.1016/j.jcp.2020.110095'>Journal of Computational Physics <b>430</b>, 110095 (2021)</a>.</div>
</dd><dt>[5]</dt>
<dd>
<div id="ifgf">L. M. Faria. <i>IFGF.jl</i>. <a href='https://github.com/WaveProp/IFGF.jl'> (2023)</a>.</div>
</dd><dt>[6]</dt>
<dd>
<div id="panagiotopoulos2020">D. Panagiotopoulos, E. Deckers and W. Desmet. <i>Krylov subspaces recycling based model order reduction for acoustic BEM systems and an error estimator</i>. <a href='https://doi.org/https://doi.org/10.1016/j.cma.2019.112755'>Computer Methods in Applied Mechanics and Engineering <b>359</b>, 112755 (2020)</a>.</div>
</dd><dt>[7]</dt>
<dd>
<div id="Paltorp2023">M. Paltorp, V. C. Henríquez, N. Aage and P. R. Andersen. <i>A Reduced Order Series Expansion for the BEM Incorporating the Boundary Layer Impedance Condition</i>. <a href='https://doi.org/10.1142/s2591728523500123'>Journal of Theoretical and Computational Acoustics (2023)</a>.</div>
</dd><dt>[8]</dt>
<dd>
<div id="hdgm15">N. J. Higham, M. R. Dennis, P. Glendinning, P. A. Martin, F. Santosa and J. Tanner. <i>The Princeton Companion to Applied Mathematics</i>. <a href='https://doi.org/https://doi.org/10.1515/9781400874477'>Princeton University Press, Princeton, NJ, USA (2015)</a>.</div>
</dd><dt>[9]</dt>
<dd>
<div id="henriquez2002a">V. C. Henriquez. <i>Numerical Transducer Modeling</i>. Phd thesis, Technical University of Denmark (2002).</div>
</dd><dt>[10]</dt>
<dd>
<div id="morse1968a">P. Morse and K. Ingard. <i>Theoretical acoustics</i>. McGraw-Hill (1968).</div>
</dd><dt>[11]</dt>
<dd>
<div id="atalla2015a">N. Atalla and F. Sgard. <i>Finite Element and Boundary Methods in Structural Acoustics and Vibration</i>. <a href='https://doi.org/10.1201/b18366'>CRC Press (2015)</a>.</div>
</dd><dt>[12]</dt>
<dd>
<div id="temkin2001elements">S. Temkin. <i>Elements of Acoustics</i>. Acoustical Society of America (2001).</div>
</dd><dt>[13]</dt>
<dd>
<div id="Preuss2023">S. Preuss, M. Paltorp, V. Cutanda Henríquez and S. Marburg. <i>Revising the Boundary Element Method for Thermoviscous Acoustics: An Iterative Approach via Schur Complement</i>. Journal of Theoretical and Computational Acoustics (2023).</div>
</dd><dt>[14]</dt>
<dd>
<div id="ihlenburg1998a">F. Ihlenburg. <i>Finite Element Analysis of Acoustic Scattering</i>. <a href='https://doi.org/https://doi.org/10.1007/b98828'>Springer (1998)</a>.</div>
</dd>
</dl></div></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../">« Home</a><a class="docs-footer-nextpage" href="../theory_rosebem/">ROSEBEM Theory »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 0.27.25 on <span class="colophon-date" title="Saturday 9 September 2023 07:23">Saturday 9 September 2023</span>. Using Julia version 1.9.3.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
